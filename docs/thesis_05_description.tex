\epigraph{\textit{The only way to learn a new programming language is by writing programs in it.}}{-- \textup{Dennis Ritchie}}

\section{Related Work}

Some work has already been done in the field of Knowledge graph validation. In this section we are exploring what other projects have achieved and their limitations.

\subsection{Bid data processing and graphs}

Having to process enormous graphs made Google propose Pregel~\cite{10.1145/1807167.1807184} a model for large-scale graph computing, back in 2010. Following the idea of \textit{think like a vertex}, other systems were introduced: GraphLab~\cite{10.14778/2212351.2212354}, PowerGraph~\cite{180251} or GraphX~\cite{186216}. Being the latter a framework that enables the implementation of parallel computing algorithms.

\subsection{Knowledge graphs}

This article is closely related to Labra's paper~\cite{https://doi.org/10.48550/arxiv.2110.11709} on utilizing Shape Expressions to generate knowledge graph subsets, where he described the approach used in this document as one of the potential implementations. MARS (Multi-Attributed Relational Structures)~\cite{ijcai2017p165}, which are a generalized concept of property graphs, are the source of inspiration for our description of Wikibase graphs. They also define MAPL (Multi-Attributed Predicate Logic) as a formalism of logic that may be applied to ontological reasoning in that work.

\subsection{Knowledge graph descriptions}

\subsection{Knowledge graph subsets}

\section{Evaluating alternatives}

\subsection{Programming Language for the implementation}

During the first meeting, that took place the 29th September 2022, we discussed the possible paths we could follow in order to develop this project. It was clear that we were willing to use a functional programming language. This way, two options arose:

\subsubsection{Haskell}

While Haskell is a purely functional programming language~\cite{wiki:Haskell} with a much cleaner theoretical foundation, there are not as many libraries for consuming RDF-formatted data. Its abstractions are more elegant, and we have the possibility of being more academic when developing the project.

\begin{lstlisting}[language=Haskell, caption=\textit{Hello World!} program written in Haskell]
main :: IO ()
main = putStrLn "Hello, World!"
\end{lstlisting}

\subsubsection{Scala}

However, Scala supports both object-oriented and functional programming~\cite{wiki:Scala_programming_language}. More in more, Scala source code can be compiled to be executed in the \textit{Java Virtual Machine}. This means, any library written to be used in Java programs, can also be imported into any Scala project. Not only that, but the initial code of this project was already written in Scala. Even more, we also have the possibility of using \textit{Apache Spark} as the engine for executing our system. As a drawback, it is not as pure as Haskell is.

\begin{lstlisting}[language=Scala, caption=\textit{Hello World!} program written in Scala 2]
object Hello {
    def main(args: Array[String]) = {
        println("Hello, world")
    }
}
\end{lstlisting}

\subsection{Cloud provider}